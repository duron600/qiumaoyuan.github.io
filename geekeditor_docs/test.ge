{"content":[{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"这里的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法能够创建一个协程，Kotlin 里协程被视作“轻量化”的线程，它是可以挂起 (suspend) 的。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;修饰的方法叫作 suspend 方法，例如这里的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"在一个协程内调用&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法（例如调用一个发起网络请求的 suspend 方法），该协程会被挂起，变为&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":",&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;和&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;都能用于创建一个协程，区别在于："},"common":{}},{"key":"list","data":{"style":"unordered","items":[{"content":"","style":"unordered","items":[]}]},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"当然，"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;也有与之对应的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法。"},"common":{}},{"key":"list","data":{"style":"unordered","items":[{"content":"","style":"unordered","items":[]}]},"common":{}},{"key":"header","data":{"content":"Channel","level":3},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 的 coroutine 包里提供了个 Channel 用于在各协程之间通信。Channel 里可以存放任意类型的数据。提供的操作就是生产者方 send, 消费者方 receive, 很常见的生产-消费模式。"},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 里的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;是个接口，继承了&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;和&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"，前者有一个&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;和一个&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法，后者有一个&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法和&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法都是 suspend 方法。"},"common":{}},{"key":"paragraph","data":{"content":"这里主要记录一下各种类型 Channel 的异同。"},"common":{}},{"key":"list","data":{"style":"unordered","items":[{"content":"","style":"unordered","items":[]}]},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 提供了一个工厂方法&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;用来创建不同类型的 Channel。不传任何参数时，默认创建的是 Rendezvous Channel；当参数为任意正整数时，创建的是 Buffered Channel；当参数为 Channel.UNLIMITED, Channel.CONFLATED 等用于指定类型的常量时，创建的就是对应类型的 Channel。"},"common":{}},{"key":"header","data":{"content":"延迟执行","level":3},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;和&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;参数可以用来指定协程的启动模式。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;可以让协程延迟执行，直到&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法被调用。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"运行这段代码会发现总运行时间为 1 秒左右。但是如果把代码中的两处&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;调用删掉，会发现用时为 2 秒左右。因为&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;会挂起当前协程，使两个协程按&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;的调用顺序执行。"},"common":{}},{"key":"header","data":{"content":"结构化并发 (Structured Concurrency)","level":3},"common":{}},{"key":"paragraph","data":{"content":"协程是可以嵌套的，每一个协程自己界定了一个范围 (scope)，限制了在其范围内的子协程的寿命。父协程被取消，所有子协程都将被取消；父协程的结束，也必须等待所有子协程结束。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法可用于在不创建协程的情况下创建一个 scope。它是个 suspend 方法，会挂起当前的协程，直至内部协程执行完毕。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"输出"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"可以看到打印 Hello 之后没有接着打印 Done，而是等待内部的两个协程执行完。如果去掉这个 coroutingScope 的调用，则会输出："},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"考虑如下代码"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"假如&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;执行出错，抛出异常，"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;会仍然在后台执行。在结构化并发的写法中，这种情况可以避免。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"header","data":{"content":"Context 和 Dispatcher","level":3},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 的协程总是运行在一个叫&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;的环境里，CoroutineContext 里包含的主要元素 (element) 有协程本身的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"，以及该协程的 dispatcher.&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;是实现了&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;和&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;接受一个可选的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;参数，该参数用于显式地指定协程及其上下文 (Context) 中的其它元素 (element) 所使用的 dispatcher. 不指定参数的时候，新的协程从父级的&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;是&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;的其中一种实现。当你给&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;或者&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法传递参数&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"实际上&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;比较适用于 CPU 计算密集型的任务。另外 Kotlin 还提供了&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"，很容易看出，这个 Dispatcher 适用于 IO 密集型的任务。如果希望协程只在主线程当中运行，可以使用&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"。"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;默认使用&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"还有一个&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;方法，它的作用是创建一个协程，然后把父协程挂起，等待代码块执行完毕，并返回结果。与&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"使用&nbsp;"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}},{"key":"paragraph","data":{"content":"&nbsp;时，新的协程会先在创建协程的那个线程中执行，直到遇到协程内部的 suspend 方法，之后的代码会在运行 suspend 代码的那个线程上执行。总之就是很随意。适用于不消耗 CPU，又不更新任何共享数据的操作。（这是官方说法。我暂时也想不到适用于哪里。）"},"common":{}},{"key":"code","data":{"lang":"","lines":[""]},"common":{}}],"typeset":"default","layout":"web"}