{"content":[{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"launch {"},"common":{}},{"key":"paragraph","data":{"content":"    val users = loadContributorsSuspend(req) //  suspend 方法"},"common":{}},{"key":"paragraph","data":{"content":"    updateResults(users, startTime)"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"suspend fun loadContributorsSuspend(service: GitHubService, req: RequestData): List&lt;User&gt; {"},"common":{}},{"key":"paragraph","data":{"content":"    ......"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"这里的 `launch` 方法能够创建一个协程，Kotlin 里协程被视作“轻量化”的线程，它是可以挂起 (suspend) 的。`suspend` 修饰的方法叫作 suspend 方法，例如这里的 `loadContributorsSuspend()`。suspend 方法只能在协程中被调用，或者被另一个 suspend 方法调用。"},"common":{}},{"key":"paragraph","data":{"content":"在一个协程内调用 `suspend` 方法（例如调用一个发起网络请求的 suspend 方法），该协程会被挂起，变为 `suspended` 状态，并被从当前线程中移除，保存在内存当中，当前线程可以继续执行其它任务。当该协程准备好继续执行时（例如网络请求完成并返回），协程会重新加入一个线程（不一定是之前的那个线程），继续执行内部剩余部分的代码。"},"common":{}},{"key":"paragraph","data":{"content":"`runBlocking`, `launch` 和 `async` 都能用于创建一个协程，区别在于："},"common":{}},{"key":"paragraph","data":{"content":"- `runBlocking` 主要是用于桥接起普通方法和 suspend 方法，桥接起 blocking world 和 non-blocking world. 通常被用作创建最顶层的协程。它的调用会引起当前线程阻塞；"},"common":{}},{"key":"paragraph","data":{"content":"- `async` 方法能够创建一个协程，并且会返回一个 Deferred 对象。Deferred 是一个泛型类，可以对其调用 `await` 方法用于获取 `async` 所返回的数据。对 `await` 方法调用会引起调用该方法的协程（也就是父协程）挂起。对于 `Collection&lt;Deferred&lt;T&gt;&gt;` 类，kotlin 还提供了一个 `awaitAll` 方法，用于获取一组 Deferred 对象的返回结果："},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"import kotlinx.coroutines.*"},"common":{}},{"key":"paragraph","data":{"content":"fun main() = runBlocking {"},"common":{}},{"key":"paragraph","data":{"content":"    val deferreds: List&lt;Deferred&lt;Int&gt;&gt; = (1..3).map {"},"common":{}},{"key":"paragraph","data":{"content":"        async {"},"common":{}},{"key":"paragraph","data":{"content":"            delay(1000L * it)"},"common":{}},{"key":"paragraph","data":{"content":"            println(\"Loading $it\")"},"common":{}},{"key":"paragraph","data":{"content":"            it"},"common":{}},{"key":"paragraph","data":{"content":"        }"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"    val sum = deferreds.awaitAll().sum()"},"common":{}},{"key":"paragraph","data":{"content":"    println(\"$sum\")"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"当然，`Collection&lt;Job&lt;T&gt;&gt;` 也有与之对应的 `joinAll()` 方法。"},"common":{}},{"key":"paragraph","data":{"content":"- `launch` 方法也能够创建一个协程，并且返回一个 Job 对象。Job 是 Deferred 的父类。如果父协程需要等待该协程执行完毕，可以对其调用 `join` 方法达到与 `Deferred.await` 类似的效果，但区别是 `join` 方法不返回值。"},"common":{}},{"key":"paragraph","data":{"content":"当然，因为 Deferred 是 Job 的子类，所以 Deferred 也可以调用 join 方法，只是这种情况下没有必要使用 Deferred，直接用 Job 即可。"},"common":{}},{"key":"paragraph","data":{"content":"### Channel"},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 的 coroutine 包里提供了个 Channel 用于在各协程之间通信。Channel 里可以存放任意类型的数据。提供的操作就是生产者方 send, 消费者方 receive, 很常见的生产-消费模式。"},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 里的 `Channel` 是个接口，继承了 `SendChannel` 和 `ReceiveChannel`，前者有一个 `send(E)` 和一个 `close()` 方法，后者有一个 `receive()` 方法。`send(E)` 方法和 `receive()` 方法都是 suspend 方法。"},"common":{}},{"key":"paragraph","data":{"content":"这里主要记录一下各种类型 Channel 的异同。"},"common":{}},{"key":"paragraph","data":{"content":"- Unlimited Channel: 容量无限，因此 `send(E)` 方法不会被挂起，但如果内存不足的话会抛出异常 `OutOfMemoryException`；当 channel 是空的的时候，`receive()` 方法会被挂起；"},"common":{}},{"key":"paragraph","data":{"content":"- Buffered Channel: 设定了容量的 Channel，`send(E)` 方法在 channel 满的时候会挂起；"},"common":{}},{"key":"paragraph","data":{"content":"- Rendezvous Channel: 相当于容量为 0 的 Buffered Channel。当 `send(E)` 方法被调用，并且 `receive()` 方法没有被调用时，`send(E)` 方法会被挂起，直到 `receive()` 方法被调用；同样，当 `receive()` 方法被调用，并且 `send(E)` 方法没有被调用的时候，`receive()` 方法会被挂起；"},"common":{}},{"key":"paragraph","data":{"content":"- Conflated Channel: `send(E)` 方法连续调用，并且 channel 里的元素没有被消费的话，先前的元素会被后来的元素所覆盖，消费方只能取到最后放进去的元素。"},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 提供了一个工厂方法 `Channel()` 用来创建不同类型的 Channel。不传任何参数时，默认创建的是 Rendezvous Channel；当参数为任意正整数时，创建的是 Buffered Channel；当参数为 Channel.UNLIMITED, Channel.CONFLATED 等用于指定类型的常量时，创建的就是对应类型的 Channel。"},"common":{}},{"key":"paragraph","data":{"content":"### 延迟执行"},"common":{}},{"key":"paragraph","data":{"content":"`launch()` 和 `async()` 的 `start` 参数可以用来指定协程的启动模式。`async(start = CoroutineStart.LAZY)` 可以让协程延迟执行，直到 `start()` 方法被调用。"},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"fun main() {"},"common":{}},{"key":"paragraph","data":{"content":"    runBlocking {"},"common":{}},{"key":"paragraph","data":{"content":"        val time = measureTimeMillis {"},"common":{}},{"key":"paragraph","data":{"content":"            val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }"},"common":{}},{"key":"paragraph","data":{"content":"            val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }"},"common":{}},{"key":"paragraph","data":{"content":"            // some computation"},"common":{}},{"key":"paragraph","data":{"content":"            one.start() // start the first one"},"common":{}},{"key":"paragraph","data":{"content":"            two.start() // start the second one"},"common":{}},{"key":"paragraph","data":{"content":"            println(\"all coroutine started\")"},"common":{}},{"key":"paragraph","data":{"content":"            println(\"The answer is ${one.await() + two.await()}\")"},"common":{}},{"key":"paragraph","data":{"content":"        }"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"Completed in $time ms\")"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"suspend fun doSomethingUsefulOne(): Int {"},"common":{}},{"key":"paragraph","data":{"content":"    delay(1000L) // pretend we are doing something useful here"},"common":{}},{"key":"paragraph","data":{"content":"    println(\"do something useful one\")"},"common":{}},{"key":"paragraph","data":{"content":"    return 13"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"suspend fun doSomethingUsefulTwo(): Int {"},"common":{}},{"key":"paragraph","data":{"content":"    delay(1000L) // pretend we are doing something useful here, too"},"common":{}},{"key":"paragraph","data":{"content":"    println(\"do something useful two\")"},"common":{}},{"key":"paragraph","data":{"content":"    return 29"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"运行这段代码会发现总运行时间为 1 秒左右。但是如果把代码中的两处 `start()` 调用删掉，会发现用时为 2 秒左右。因为 `await()` 会挂起当前协程，使两个协程按 `await()` 的调用顺序执行。"},"common":{}},{"key":"paragraph","data":{"content":"### 结构化并发 (Structured Concurrency)"},"common":{}},{"key":"paragraph","data":{"content":"协程是可以嵌套的，每一个协程自己界定了一个范围 (scope)，限制了在其范围内的子协程的寿命。父协程被取消，所有子协程都将被取消；父协程的结束，也必须等待所有子协程结束。"},"common":{}},{"key":"paragraph","data":{"content":"`coroutineScope()` 方法可用于在不创建协程的情况下创建一个 scope。它是个 suspend 方法，会挂起当前的协程，直至内部协程执行完毕。"},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"fun main() {"},"common":{}},{"key":"paragraph","data":{"content":"    runBlocking {"},"common":{}},{"key":"paragraph","data":{"content":"        coroutineScope {"},"common":{}},{"key":"paragraph","data":{"content":"            launch {"},"common":{}},{"key":"paragraph","data":{"content":"                delay(2000)"},"common":{}},{"key":"paragraph","data":{"content":"                println(\"- World 2\")"},"common":{}},{"key":"paragraph","data":{"content":"            }"},"common":{}},{"key":"paragraph","data":{"content":"            launch {"},"common":{}},{"key":"paragraph","data":{"content":"                delay(1000)"},"common":{}},{"key":"paragraph","data":{"content":"                println(\"- World\")"},"common":{}},{"key":"paragraph","data":{"content":"            }"},"common":{}},{"key":"paragraph","data":{"content":"            println(\"Hello\")"},"common":{}},{"key":"paragraph","data":{"content":"        }"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"Done\")"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"输出"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"Hello"},"common":{}},{"key":"paragraph","data":{"content":"- World"},"common":{}},{"key":"paragraph","data":{"content":"- World 2"},"common":{}},{"key":"paragraph","data":{"content":"Done"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"可以看到打印 Hello 之后没有接着打印 Done，而是等待内部的两个协程执行完。如果去掉这个 coroutingScope 的调用，则会输出："},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"Hello"},"common":{}},{"key":"paragraph","data":{"content":"Done"},"common":{}},{"key":"paragraph","data":{"content":"- World"},"common":{}},{"key":"paragraph","data":{"content":"- World 2"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"考虑如下代码"},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"// The result type of somethingUsefulOneAsync is Deferred&lt;Int&gt;"},"common":{}},{"key":"paragraph","data":{"content":"@OptIn(DelicateCoroutinesApi::class)"},"common":{}},{"key":"paragraph","data":{"content":"fun somethingUsefulOneAsync() = GlobalScope.async {"},"common":{}},{"key":"paragraph","data":{"content":"    doSomethingUsefulOne()"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"// The result type of somethingUsefulTwoAsync is Deferred&lt;Int&gt;"},"common":{}},{"key":"paragraph","data":{"content":"@OptIn(DelicateCoroutinesApi::class)"},"common":{}},{"key":"paragraph","data":{"content":"fun somethingUsefulTwoAsync() = GlobalScope.async {"},"common":{}},{"key":"paragraph","data":{"content":"    doSomethingUsefulTwo()"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"// note that we don't have `runBlocking` to the right of `main` in this example"},"common":{}},{"key":"paragraph","data":{"content":"fun main() {"},"common":{}},{"key":"paragraph","data":{"content":"    val time = measureTimeMillis {"},"common":{}},{"key":"paragraph","data":{"content":"        // we can initiate async actions outside of a coroutine"},"common":{}},{"key":"paragraph","data":{"content":"        val one = somethingUsefulOneAsync()"},"common":{}},{"key":"paragraph","data":{"content":"        val two = somethingUsefulTwoAsync()"},"common":{}},{"key":"paragraph","data":{"content":"        // but waiting for a result must involve either suspending or blocking."},"common":{}},{"key":"paragraph","data":{"content":"        // here we use `runBlocking { ... }` to block the main thread while waiting for the result"},"common":{}},{"key":"paragraph","data":{"content":"        runBlocking {"},"common":{}},{"key":"paragraph","data":{"content":"            println(\"The answer is ${one.await() + two.await()}\")"},"common":{}},{"key":"paragraph","data":{"content":"        }"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"    println(\"Completed in $time ms\")"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"假如 `two` 执行出错，抛出异常，`one` 会仍然在后台执行。在结构化并发的写法中，这种情况可以避免。"},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"suspend fun concurrentSum(): Int = coroutineScope {"},"common":{}},{"key":"paragraph","data":{"content":"    val one = async { doSomethingUsefulOne() }"},"common":{}},{"key":"paragraph","data":{"content":"    val two = async { doSomethingUsefulTwo() }"},"common":{}},{"key":"paragraph","data":{"content":"    one.await() + two.await()"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"fun main() = runBlocking {"},"common":{}},{"key":"paragraph","data":{"content":"    val time = measureTimeMillis {"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"The answer is ${concurrentSum()}\")"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"    println(\"Completed in $time ms\")"},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":"### Context 和 Dispatcher"},"common":{}},{"key":"paragraph","data":{"content":"Kotlin 的协程总是运行在一个叫 `CoroutineContext` 的环境里，CoroutineContext 里包含的主要元素 (element) 有协程本身的 `Job`，以及该协程的 dispatcher. `CoroutineDispatcher` 是实现了 `CoroutineContext` 的一个抽象类，它可以用来决定协程该运行在哪个线程，或哪个线程池里的线程上。"},"common":{}},{"key":"paragraph","data":{"content":"`launch` 和 `async` 接受一个可选的 `CoroutineContext` 参数，该参数用于显式地指定协程及其上下文 (Context) 中的其它元素 (element) 所使用的 dispatcher. 不指定参数的时候，新的协程从父级的 `CoroutineScope` 里继承 context 和 dispatcher。"},"common":{}},{"key":"paragraph","data":{"content":"`Dispatchers.Default` 是 `CoroutineDispatcher` 的其中一种实现。当你给 `async` 或者 `launch` 方法传递参数 `Dispatchers.Default` 时，它会从 JVM 的一个共享线程池里获取空闲的线程。这个共享线程池的线程数量与 CPU 的核心数量相等。但是当 CPU 只有一个核心时，线程池里会有两个线程。只要并发量足够大，便可以在日志中打印线程 ID 来观察到效果。同时我们会看到，启动协程的线程，和协程由 suspended 状态恢复后所在的线程很多时候并不是同一个线程。"},"common":{}},{"key":"paragraph","data":{"content":"实际上 `Dispatchers.Default` 比较适用于 CPU 计算密集型的任务。另外 Kotlin 还提供了 `Dispatchers.IO`，很容易看出，这个 Dispatcher 适用于 IO 密集型的任务。如果希望协程只在主线程当中运行，可以使用 `Dispatchers.Main`。`MainScope` 默认使用 `Dispatchers.Main`."},"common":{}},{"key":"paragraph","data":{"content":"还有一个 `withContext()` 方法，它的作用是创建一个协程，然后把父协程挂起，等待代码块执行完毕，并返回结果。与 `async{}.await()` 效果相同。"},"common":{}},{"key":"paragraph","data":{"content":"使用 `Dispatchers.Unconfined` 时，新的协程会先在创建协程的那个线程中执行，直到遇到协程内部的 suspend 方法，之后的代码会在运行 suspend 代码的那个线程上执行。总之就是很随意。适用于不消耗 CPU，又不更新任何共享数据的操作。（这是官方说法。我暂时也想不到适用于哪里。）"},"common":{}},{"key":"paragraph","data":{"content":"```kotlin"},"common":{}},{"key":"paragraph","data":{"content":"fun main() = runBlocking&lt;Unit&gt; {"},"common":{}},{"key":"paragraph","data":{"content":"    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")"},"common":{}},{"key":"paragraph","data":{"content":"        delay(500)"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")"},"common":{}},{"key":"paragraph","data":{"content":"    }"},"common":{}},{"key":"paragraph","data":{"content":"    launch { // context of the parent, main runBlocking coroutine"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")"},"common":{}},{"key":"paragraph","data":{"content":"        delay(1000)"},"common":{}},{"key":"paragraph","data":{"content":"        println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")"},"common":{}},{"key":"paragraph","data":{"content":"    }    "},"common":{}},{"key":"paragraph","data":{"content":"}"},"common":{}},{"key":"paragraph","data":{"content":"// Unconfined      : I'm working in thread main @coroutine#2"},"common":{}},{"key":"paragraph","data":{"content":"// main runBlocking: I'm working in thread main @coroutine#3"},"common":{}},{"key":"paragraph","data":{"content":"// Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor@coroutine#2"},"common":{}},{"key":"paragraph","data":{"content":"// main runBlocking: After delay in thread main @coroutine#3"},"common":{}},{"key":"paragraph","data":{"content":"```"},"common":{}},{"key":"paragraph","data":{"content":""},"common":{}}],"typeset":"default","layout":"web"}